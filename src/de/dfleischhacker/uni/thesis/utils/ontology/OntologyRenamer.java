/*
 * 
 * OntologyRenamer.java
 * 
 * Software License Agreement (BSD License)
 * 
 * Copyright (c) 2009 Daniel Fleischhacker <dev@dfleischhacker.de>
 * All rights reserved.
 * 
 * Redistribution and use of this software in source and binary forms, with or
 * without modification, are permitted provided that the following conditions
 * are met:
 * 
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 * 
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


package de.dfleischhacker.uni.thesis.utils.ontology;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.semanticweb.owl.model.OWLEntity;
import org.semanticweb.owl.model.OWLOntology;
import org.semanticweb.owl.model.OWLOntologyChange;
import org.semanticweb.owl.model.OWLOntologyChangeException;
import org.semanticweb.owl.util.OWLEntityRenamer;
import de.dfleischhacker.uni.thesis.GlobalSettings;
import de.dfleischhacker.uni.thesis.semantic.SemanticModule;
import de.dfleischhacker.uni.thesis.utils.types.TypeMap;

/**
 * This class provides methods to rename entities contained in two ontologies.
 * Renaming is done to guarantee unique names across both ontologies. 
 * 
 * @author Daniel Fleischhacker <dev@dfleischhacker.de>
 */
public class OntologyRenamer {
	private TypeMap map;
	private Ontology onto1;
	private Ontology onto2;
	private SemanticModule sem;
	
	/**
	 * Hashmap containing all blacklisted items
	 */
	static HashMap<String,Boolean> blacklist;

	/**
	 * List containing all blacklisted namespaces
	 */
	static LinkedList<String> blacklistNamespaces;

	// static initializer block to fill blacklists
	static {
		blacklist = new HashMap<String,Boolean>();

		blacklistNamespaces = new LinkedList<String>();
	}

	/**
	 * Renames all entities of the given to ontology so that each of these has
	 * a unique namespace which guarantees that no name clashes are possible
	 * during the merge.
	 *
	 * Furthermore, it creates a TypeMap containing the types of all entities.
	 *
	 * <b>This renaming is done in the given ontologies and NOT in copies, so
	 * be aware of the side effects</b>
	 * 
	 * @param onto1 ontology 1
	 * @param onto2 ontology 2
	 */
	public OntologyRenamer(Ontology onto1, Ontology onto2) throws MergingException {
		this.onto1 = onto1;
		this.onto2 = onto2;

		/*
		 * rename all entities of the original ontologies to prevent
		 * name clashes while merging
		 */
		// created renamer using a dummy hashset
		HashSet<OWLOntology> dummyMap = new HashSet<OWLOntology>();
		dummyMap.add(onto1);
		OWLEntityRenamer renamer = new OWLEntityRenamer(onto1.getManager(), dummyMap);

		for (OWLEntity ent : onto1.getReferencedEntities()) {
			List<OWLOntologyChange> changes = renamer.changeURI(ent.getURI(),
				resolveURI(1, ent.getURI()));
			try {
				onto1.getManager().applyChanges(changes);
			} catch (OWLOntologyChangeException ex) {
				throw new MergingException(ex.getMessage());
			}
		}

		dummyMap = new HashSet<OWLOntology>();
		dummyMap.add(onto2);
		renamer = new OWLEntityRenamer(onto2.getManager(), dummyMap);

		for (OWLEntity ent : onto2.getReferencedEntities()) {
			List<OWLOntologyChange> changes = renamer.changeURI(ent.getURI(),
				resolveURI(2, ent.getURI()));
			try {
				onto2.getManager().applyChanges(changes);
			} catch (OWLOntologyChangeException ex) {
				throw new MergingException(ex.getMessage());
			}
		}

		// generate typemap for use in the semantic module
		map = new TypeMap(onto1, onto2);
	}

	/**
	 * Returns the typemap generated by this merger
	 * @return typemap containing entities' types
	 */
	public TypeMap getTypeMap() {
		return map;
	}

	/**
	 * Generates a new unique URI based on the given URI and the given number.
	 * The number should be the ontology the corresponding entity is assigned to.
	 * @param onto number for ontology
	 * @param uri uri to base the new unique URI on
	 * @return unique URI based on the given URI and number
	 */
	public static URI resolveURI(int onto, URI uri) {
		return resolveURI(onto, uri.toString());
	}

	/**
	 * Generates a new unique URI based on the given URI and the given number.
	 * The number should be the ontology the corresponding entity is assigned to.
	 * @param onto number for ontology
	 * @param uri uri to base the new unique URI on
	 * @return unique URI based on the given URI and number
	 */
	public static URI resolveURI(int onto, String uri) {
		// to not change identifier of blacklisted entites (i.e. RDF keywords)
		if (isBlacklisted(uri)) {
			return URI.create(uri);
		}

		String uriString = uri.replaceAll("://", "___");
		try {
			return new URI(GlobalSettings.ONTO_PREFIX + onto + "/" + uriString);
		} catch (URISyntaxException ex) {
			Logger.getLogger(OntologyManager.class.getName()).log(Level.SEVERE, null, ex);
		}

		return null;
	}

	/**
	 * Checks if the given URI is blacklisted for the renaming step either by
	 * it's namespace or individually.
	 * @param uri URI to check
	 * @return true if blacklisted, otherwise false
	 */
	public static boolean isBlacklisted(String uri) {
		if (blacklist.containsKey(uri))
			return true;
		for (String namespace : blacklistNamespaces) {
			if (uri.startsWith(namespace))
				return true;
		}
		return false;
	}
}
